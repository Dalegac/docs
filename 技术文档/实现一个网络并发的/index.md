<!--
 * @Author: Dalegac
 * @Date: 2021-08-20 14:01:04
 * @LastEditTime: 2021-08-23 00:02:37
 * @LastEditors: Dalegac
 * @Description: Just say something
-->

## 网络并发

### HTTP/1.0/1.1/2.0 在并发请求上主要的区别是什么？

1. HTTP/1.0
   每个 TCP 连接只能发送一个请求，当服务器响应后就会关闭这个连接，下一次请求需要再次建立 TCP 连接。

追问：你说每个连接只能发一个请求，这个连接是指 HTTP 连接还是 TCP 连接？

2. HTTP/1.1

默认采用持久连接，TCP，Connection:keep-alive

关闭持久连接：Connection:close

管道机制，在同一个 TCP 链接里，允许多个请求同时请求，一问一答的形式
所有的数据通信是有序的，A，B，C，A 先到达服务器开始响应，10s，队头阻塞

3. HTTP/2.0

加了双工模式，服务器也能同时处理多个请求了，解决了队头阻塞的问题。
多路复用，没有次序概念了，同一个连接进行多个请求。
加了服务器推送功能，服务器主动推送。

### HTTP/1.1 的长连接和 2.0 的多路复用有什么区别

1.1: 同一时间一个 TCP 连接只能处理一个请求，采用一问一答的形式，上一个请求响应后才能处理下一个请求。

追问：听说 chrome 浏览器支持最大 6 个同域请求的并发

因为 chrome 支持最大六个 TCP 连接

2.0：同域名上的所有通信都在单个连接上完成，单个连接上可以并行交错的进行请求和响应

### 为什么 1.1 不能实现多路复用呢？

HTTP/2.0 是基于二进制帧的协议，HTTP/1.1 是基于文本分隔解析的协议。

1.1 的报文结构里，服务器需要不断的读入字节，直到遇到换行符，处理的顺序是串行的，

GET / HTTP/1.1
Accept:
host:
referer:

POST

2.0 以帧为最小数据单元，每个帧都会有标识自己属于哪个流，多个帧组成一个流。

多路复用，其实就是一个 TCP 里面存在多条流

### 前端代码里有什么方式可以控制最大并发量？

达到并发量之前继续往里推、执行，达到并发量之后置入 pendingList 里面，正在执行的池子里结束一个，就从下面的池子里取一个。

### 如果任务有优先级的概念，需要允许高优任务的插入呢？

- 执行的时候对池子进行排序
- 添加的时候对池子进行排序
